(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{740:function(v,_,e){"use strict";e.r(_);var t=e(5),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"react最新的生命周期是怎么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react最新的生命周期是怎么样的"}},[v._v("#")]),v._v(" React最新的生命周期是怎么样的？")]),v._v(" "),e("p",[v._v("在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("componentWillMount")])]),v._v(" "),e("li",[e("p",[v._v("componentWillReceiveProps")])]),v._v(" "),e("li",[e("p",[v._v("componentWillUpdate")])])]),v._v(" "),e("p",[v._v("当它们被删除后，将会只保留三个添加了"),e("code",[v._v("UNSAVE_")]),v._v("前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。")]),v._v(" "),e("p",[v._v("⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。")]),v._v(" "),e("p",[e("strong",[v._v("挂载阶段")])]),v._v(" "),e("p",[e("code",[v._v("constructor")]),v._v(" ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 "),e("code",[v._v("state")]),v._v(" 状态对象、或给⾃定义⽅法绑定 "),e("code",[v._v("this")])]),v._v(" "),e("p",[e("code",[v._v("getDerivedStateFromProps")]),v._v(" ：这是个静态⽅法，当我们接收到新的属性后想要去修改 "),e("code",[v._v("state")]),v._v(" 时可以使用")]),v._v(" "),e("p",[e("code",[v._v("render")]),v._v("：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容")]),v._v(" "),e("p",[e("code",[v._v("componentDidMount")]),v._v(" ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 "),e("code",[v._v("componentWillUnmount")]),v._v(" 中取消订阅，即释放资源")]),v._v(" "),e("p",[e("strong",[v._v("更新阶段")])]),v._v(" "),e("p",[e("code",[v._v("getDerivedStateFromProps")]),v._v(" ：此⽅法在更新个挂载阶段都可能会调⽤")]),v._v(" "),e("p",[e("code",[v._v("shouldComponentUpdate")]),v._v(" ：该函数有两个参数 "),e("code",[v._v("nextProps")]),v._v(" 和 "),e("code",[v._v("nextState")]),v._v("，表示新的属性和变化之后的状态；它返回⼀个布尔值，"),e("code",[v._v("true")]),v._v(" 表示会触发重新渲染，"),e("code",[v._v("false")]),v._v(" 则表示不会触发重新渲染，默认返回 "),e("code",[v._v("true")]),v._v("。我们通常利⽤该⽣命周期来优化 React 程序的性能")]),v._v(" "),e("p",[e("code",[v._v("render")]),v._v(" ：更新阶段也会触发此⽣命周期")]),v._v(" "),e("p",[e("code",[v._v("getSnapshotBeforeUpdate")]),v._v(" ：该⽅法在 "),e("code",[v._v("render")]),v._v(" 之后、在 "),e("code",[v._v("componentDidUpdate")]),v._v(" 之前被调⽤，它有两个参数 "),e("code",[v._v("prevProps")]),v._v(" 和"),e("code",[v._v("prevState")]),v._v("，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 "),e("code",[v._v("componentDidUpdate")]),v._v(" ，如果不想要返回值则返回 "),e("code",[v._v("null")]),v._v(" 即可。该⽣命周期必须与 "),e("code",[v._v("componentDidUpdate")]),v._v(" 搭配使⽤")]),v._v(" "),e("p",[e("code",[v._v("componentDidUpdate")]),v._v(" ：该⽅法在 "),e("code",[v._v("getSnapshotBeforeUpdate")]),v._v(" ⽅法之后被调⽤，它有三个参数 "),e("code",[v._v("prevProps")]),v._v(" 、"),e("code",[v._v("prevState")]),v._v(" 、"),e("code",[v._v("snapshot")]),v._v(" ，表示之前的属性、之前的状态、以及"),e("code",[v._v("snapshot")]),v._v("。第三个参数是 "),e("code",[v._v("getSnapshotBeforeUpdate")]),v._v(" 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ "),e("code",[v._v("getSnapshotBeforeUpdate")]),v._v("，然后在 "),e("code",[v._v("componentDidUpdate")]),v._v(" 中统⼀触发回调或更新状态")]),v._v(" "),e("p",[e("strong",[v._v("卸载阶段")])]),v._v(" "),e("p",[e("code",[v._v("componentWillUnmount")]),v._v(" ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[v._v("React生命周期图形示意工具"),e("OutboundLink")],1)]),v._v(" "),e("h2",{attrs:{id:"在react中网络请求应该放在哪个生命周期中发起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在react中网络请求应该放在哪个生命周期中发起"}},[v._v("#")]),v._v(" 在React中网络请求应该放在哪个生命周期中发起？")]),v._v(" "),e("p",[v._v("有人认为 React 中的网络异步请求，应该放在 "),e("code",[v._v("componentWillMount")]),v._v(" 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。")]),v._v(" "),e("p",[v._v("由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 "),e("code",[v._v("componentWillMount")]),v._v(" 执行完成任何事情，而是继续往前执行并继续做 "),e("code",[v._v("render")]),v._v(" ，没有办法 “暂停” 渲染以等待远程数据的返回。")]),v._v(" "),e("p",[v._v("⽽且，在 "),e("code",[v._v("componentWillMount")]),v._v(" 中发起请求会存在⼀系列潜在问题：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("在用 React 作为服务器渲染（SSR）时，如果在 "),e("code",[v._v("componentWillMount")]),v._v(" 中进行数据的获取，则 "),e("code",[v._v("fetch data")]),v._v(" 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求")])]),v._v(" "),e("li",[e("p",[v._v("在 React 16 使用 React Fiber 架构重写后，"),e("code",[v._v("componentWillMount")]),v._v(" 可能会在⼀次渲染中被多次调⽤。")])])]),v._v(" "),e("p",[e("strong",[v._v("⽬前官⽅推荐的是在 "),e("code",[v._v("componentDidmount")]),v._v(" 中进行异步请求。")])]),v._v(" "),e("p",[v._v("如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 "),e("code",[v._v("constructor")]),v._v(" 中进行。")]),v._v(" "),e("p",[v._v("另外，由于在 React 17 之后 "),e("code",[v._v("componentWillMount")]),v._v(" 被废弃仅保留 "),e("code",[v._v("UNSAFE_componentWillMount")]),v._v("，所以要慎用该生命周期。")]),v._v(" "),e("h2",{attrs:{id:"setstate是同步的还是异步的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate是同步的还是异步的"}},[v._v("#")]),v._v(" setState是同步的还是异步的？")]),v._v(" "),e("p",[v._v("答案是：有时表现出异步，有时表现出同步！")]),v._v(" "),e("ul",[e("li",[v._v("在合成事件和生命周期钩⼦函数中是异步的")]),v._v(" "),e("li",[v._v("在原⽣事件和 "),e("code",[v._v("setTimeout")]),v._v(" 中是同步的")])]),v._v(" "),e("p",[e("code",[v._v("setState")]),v._v(" 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。")]),v._v(" "),e("p",[v._v("当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：")]),v._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[v._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("partialState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("p",[v._v("此外，"),e("code",[v._v("setState")]),v._v(" 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 "),e("code",[v._v("setTimeout")]),v._v(" 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 "),e("code",[v._v("setState")]),v._v("，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 "),e("code",[v._v("setState")]),v._v(" 多个不同的值，则会在更新时对其进⾏合并批量更新。")]),v._v(" "),e("h2",{attrs:{id:"react中如何实现组件间的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react中如何实现组件间的通信"}},[v._v("#")]),v._v(" React中如何实现组件间的通信？")]),v._v(" "),e("p",[v._v("组件间通信⽅式一共有如下几种：")]),v._v(" "),e("ol",[e("li",[v._v("⽗组件向⼦组件通讯")])]),v._v(" "),e("p",[v._v("⽗组件可以通过向⼦组件传 "),e("code",[v._v("props")]),v._v(" 的⽅式来实现父到子的通讯。")]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[v._v("⼦组件向⽗组件通讯")])]),v._v(" "),e("p",[v._v("可以采用 "),e("code",[v._v("props + 回调")]),v._v(" 的⽅式。")]),v._v(" "),e("p",[v._v("当⽗组件向⼦组件传递 "),e("code",[v._v("props")]),v._v(" 进⾏通讯时，可在该 "),e("code",[v._v("props")]),v._v(" 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 "),e("code",[v._v("props")]),v._v(" 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 "),e("code",[v._v("setState")]),v._v(" 更新到⽗组件上。")]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[v._v("兄弟组件通信")])]),v._v(" "),e("p",[v._v("可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。")]),v._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[v._v("跨层级通信")])]),v._v(" "),e("p",[v._v("可以采用 React 中的 "),e("code",[v._v("Context")]),v._v(" 来实现跨越多层的全局数据通信。")]),v._v(" "),e("p",[e("code",[v._v("Context")]),v._v(" 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。")]),v._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[v._v("发布订阅模式")])]),v._v(" "),e("p",[v._v("发布者发布事件，订阅者监听到事件后做出反应。")]),v._v(" "),e("p",[v._v("我们可以通过引⼊ "),e("code",[v._v("event")]),v._v(" 模块进⾏此种方式的通信。")]),v._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[v._v("全局状态管理⼯具")])]),v._v(" "),e("p",[v._v("可以借助 "),e("code",[v._v("Redux")]),v._v(" 或 "),e("code",[v._v("Mobx")]),v._v(" 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527234344.png",alt:""}})]),v._v(" "),e("h2",{attrs:{id:"react存在哪些性能优化手段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react存在哪些性能优化手段"}},[v._v("#")]),v._v(" React存在哪些性能优化手段？")]),v._v(" "),e("p",[v._v("前端项目的性能手段，其实都是相通的。我们可以参考文章："),e("a",{attrs:{href:"https://blog.csdn.net/weixin_33976072/article/details/93168109",target:"_blank",rel:"noopener noreferrer"}},[v._v("前端性能优化"),e("OutboundLink")],1)]),v._v(" "),e("h2",{attrs:{id:"react中如何进行组件和逻辑的复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react中如何进行组件和逻辑的复用"}},[v._v("#")]),v._v(" React中如何进行组件和逻辑的复用？")]),v._v(" "),e("p",[v._v("React 中的组件抽象的技术有以下几种:")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("混合（mixin，官方已废弃）")])]),v._v(" "),e("li",[e("p",[v._v("⾼阶组件（hoc）：属性代理、反向继承")])]),v._v(" "),e("li",[e("p",[v._v("渲染属性（render props）")])]),v._v(" "),e("li",[e("p",[v._v("React Hooks（配合函数式组件使用，函数拆分的复用理念）")])])]),v._v(" "),e("h2",{attrs:{id:"mixin、hoc、render-props、react-hooks的优缺点分别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin、hoc、render-props、react-hooks的优缺点分别是什么"}},[v._v("#")]),v._v(" Mixin、HoC、Render props、React Hooks的优缺点分别是什么？")]),v._v(" "),e("p",[e("strong",[v._v("Mixin")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系）")])]),v._v(" "),e("li",[e("p",[v._v("多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突")])]),v._v(" "),e("li",[e("p",[v._v("Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增")])]),v._v(" "),e("li",[e("p",[v._v("隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响")])]),v._v(" "),e("li",[e("p",[v._v("33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它")])]),v._v(" "),e("li",[e("p",[v._v("Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出")])])])])]),v._v(" "),e("p",[e("strong",[v._v("HoC")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("p",[v._v("相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。")]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 "),e("code",[v._v("shouldComponentUpdate")]),v._v(" 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 "),e("code",[v._v("React.PureComponent")]),v._v(" 解决了这个问题")])]),v._v(" "),e("li",[e("p",[v._v("Ref 传递问题：Ref 被隔断。后来出现了 "),e("code",[v._v("React.forwardRef")]),v._v(" 来解决了这个问题")])]),v._v(" "),e("li",[e("p",[v._v("包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本")])]),v._v(" "),e("li",[e("p",[v._v("命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性")])]),v._v(" "),e("li",[e("p",[v._v("不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒")])])]),v._v(" "),e("p",[e("strong",[v._v("Render Props")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("p",[v._v("上述所说的 HoC 缺点，使用 Render Props 都可得到解决。")]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单")])]),v._v(" "),e("li",[e("p",[v._v("嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题")])])]),v._v(" "),e("p",[e("strong",[v._v("React Hooks")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁")])]),v._v(" "),e("li",[e("p",[v._v("解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦")])]),v._v(" "),e("li",[e("p",[v._v("组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富")])]),v._v(" "),e("li",[e("p",[v._v("函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题:")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("this 指向容易错误")])]),v._v(" "),e("li",[e("p",[v._v("分割在不同声明周期中的逻辑会使得代码难以理解和维护")])]),v._v(" "),e("li",[e("p",[v._v("代码复⽤成本⾼（⾼阶组件容易使代码量剧增）")])])])])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("有额外的学习成本（需要学习和区分类组件、函数组件）")])]),v._v(" "),e("li",[e("p",[v._v("写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本")])]),v._v(" "),e("li",[e("p",[v._v("破坏了 "),e("code",[v._v("PureComponent")]),v._v("、"),e("code",[v._v("React.memo")]),v._v(" 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 "),e("code",[v._v("render()")]),v._v(" 都要重新")])])]),v._v(" "),e("p",[v._v("创建事件处理函数）")]),v._v(" "),e("ul",[e("li",[v._v("在闭包场景中可能会引⽤到旧的 state、props 值")]),v._v(" "),e("li",[v._v("内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”）")]),v._v(" "),e("li",[e("code",[v._v("React.memo")]),v._v(" 并不能完全替代 "),e("code",[v._v("shouldComponentUpdate")]),v._v("（因为获取不到 state 的变化，只针对 props 的变化）")])]),v._v(" "),e("h2",{attrs:{id:"redux的工作流程是怎么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux的工作流程是怎么样的"}},[v._v("#")]),v._v(" Redux的工作流程是怎么样的？")]),v._v(" "),e("p",[e("strong",[v._v("核心概念")])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("Store")]),v._v("：一个保存数据的容器，整个应⽤只有⼀个 Store")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("State")]),v._v("：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Action")]),v._v("：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Action Creator")]),v._v("：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("Reducer")]),v._v("：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("dispatch")]),v._v("：是 View 发送 Action 的唯⼀⽅法")])])]),v._v(" "),e("p",[e("strong",[v._v("⼯作流程")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527234349.png",alt:""}})]),v._v(" "),e("p",[v._v("⼀次⽤户交互的流程如下：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 "),e("code",[v._v("dispatch")]),v._v(" ⽅法")])]),v._v(" "),e("li",[e("p",[v._v("然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State")])]),v._v(" "),e("li",[e("p",[v._v("State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新")])])]),v._v(" "),e("p",[v._v("注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。")]),v._v(" "),e("h2",{attrs:{id:"react-redux这个库是如何工作的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-redux这个库是如何工作的"}},[v._v("#")]),v._v(" react-redux这个库是如何工作的？")]),v._v(" "),e("p",[e("strong",[v._v("核心概念")])]),v._v(" "),e("p",[e("strong",[e("code",[v._v("Provider")])])]),v._v(" "),e("p",[v._v("Provider 的作⽤是从最外部封装了整个应⽤，并向 "),e("code",[v._v("connect")]),v._v(" 模块传递 "),e("code",[v._v("store")]),v._v(" 。")]),v._v(" "),e("p",[e("strong",[e("code",[v._v("connect")])])]),v._v(" "),e("p",[v._v("负责将 React 和 Redux 关联起来，它的作用主要如下：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("获取 "),e("code",[v._v("state")]),v._v("："),e("code",[v._v("connect")]),v._v(" 先通过 "),e("code",[v._v("context")]),v._v(" 来获取存放在 "),e("code",[v._v("Provider")]),v._v(" 中的 "),e("code",[v._v("store")]),v._v("，然后通过 "),e("code",[v._v("store.getState()")]),v._v(" 来获取整个 "),e("code",[v._v("store tree")]),v._v(" 上所存放的 "),e("code",[v._v("state")])])]),v._v(" "),e("li",[e("p",[v._v("包装原组件："),e("code",[v._v("connect")]),v._v(" 将 "),e("code",[v._v("state")]),v._v(" 和 "),e("code",[v._v("action")]),v._v(" 通过 "),e("code",[v._v("props")]),v._v(" 传⼊到原组件的内部，并调用 "),e("code",[v._v("wrapWithConnect")]),v._v(" 函数来包装和返回⼀个 "),e("code",[v._v("Connect")]),v._v(" 对象，"),e("code",[v._v("Connect")]),v._v(" 对象重新 "),e("code",[v._v("render")]),v._v(" 外部传⼊的原组件，并把 "),e("code",[v._v("connect")]),v._v(" 中传⼊的 "),e("code",[v._v("mapStateToProps")]),v._v(" 和 "),e("code",[v._v("mapDispatchToProps")]),v._v(" 与组件原有的 "),e("code",[v._v("props")]),v._v(" 合并后，通过属性的⽅式传给包装组件")])]),v._v(" "),e("li",[e("p",[v._v("监听 "),e("code",[v._v("store tree")]),v._v(" 变化："),e("code",[v._v("connect")]),v._v(" 缓存了 "),e("code",[v._v("store tree")]),v._v(" 中 "),e("code",[v._v("state")]),v._v(" 的状态，通过对比当前 "),e("code",[v._v("state")]),v._v(" 和变更前 "),e("code",[v._v("state")]),v._v("，确定是否需要调⽤ "),e("code",[v._v("this.setState()")]),v._v(" ⽅法，以此触发 "),e("code",[v._v("Connect")]),v._v(" 及其⼦组件的重新渲染")])])]),v._v(" "),e("p",[e("strong",[v._v("流程图")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://wuxiaohui-1254415986.cos.ap-nanjing.myqcloud.com/uPic/20210527234353.png",alt:""}})]),v._v(" "),e("h2",{attrs:{id:"redux和mobx的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux和mobx的区别"}},[v._v("#")]),v._v(" Redux和Mobx的区别？")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("比较点")]),v._v(" "),e("th",[v._v("Redux")]),v._v(" "),e("th",[v._v("Mobx")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("存储方式")]),v._v(" "),e("td",[v._v("保存在单⼀的 store 中")]),v._v(" "),e("td",[v._v("保存在分散的多个 store 中")])]),v._v(" "),e("tr",[e("td",[v._v("数据结构")]),v._v(" "),e("td",[v._v("使⽤ plain object 保存数据，需要⼿动处理变化后的操作")]),v._v(" "),e("td",[v._v("使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex）")])]),v._v(" "),e("tr",[e("td",[v._v("数据可变性")]),v._v(" "),e("td",[v._v("不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态")]),v._v(" "),e("td",[v._v("状态是可变的，可直接进⾏修改")])]),v._v(" "),e("tr",[e("td",[v._v("难易度")]),v._v(" "),e("td",[v._v("比较复杂")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤")]),v._v(" "),e("td",[v._v("比较简单")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("使用面向对象的编程思维")]),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("调试")]),v._v(" "),e("td",[v._v("容易")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("使用纯函数，并提供了时间回溯⼯具，因此调试直观方便")]),v._v(" "),e("td",[v._v("⽐较困难")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("有更多的对象抽象和封装，调试会⽐较困难")]),v._v(" "),e("td"),v._v(" "),e("td")])])]),v._v(" "),e("p",[e("strong",[v._v("使⽤场景")])]),v._v(" "),e("p",[e("code",[v._v("Mobx")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼")])]),v._v(" "),e("li",[e("p",[v._v("适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率")])])]),v._v(" "),e("p",[e("code",[v._v("Redux")])]),v._v(" "),e("ul",[e("li",[v._v("适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作")])]),v._v(" "),e("p",[v._v("我们也可以在一个项目中同时使用 "),e("code",[v._v("Mobx")]),v._v(" 和 "),e("code",[v._v("Redux")]),v._v(" ，让两者发挥各自的长处，比如：")]),v._v(" "),e("ul",[e("li",[v._v("使用 "),e("code",[v._v("Redux")]),v._v(" 作为全局状态管理")]),v._v(" "),e("li",[v._v("使⽤ "),e("code",[v._v("Mobx")]),v._v("作为组件的局部状态管理器")])]),v._v(" "),e("h2",{attrs:{id:"在redux中如何进行异步操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在redux中如何进行异步操作"}},[v._v("#")]),v._v(" 在Redux中如何进行异步操作？")]),v._v(" "),e("p",[v._v("一般项目中，我们可以直接在 "),e("code",[v._v("componentDidMount")]),v._v(" 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。")]),v._v(" "),e("p",[v._v("Redux 其实有多种异步中间件，但当下主流的只有两种："),e("code",[v._v("redux-thunk")]),v._v(" 和 "),e("code",[v._v("redux-saga")]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("redux-thunk")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码")])]),v._v(" "),e("li",[e("p",[v._v("使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单")])])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的")])]),v._v(" "),e("li",[e("p",[v._v("耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理")])]),v._v(" "),e("li",[e("p",[v._v("功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装")])])]),v._v(" "),e("p",[e("strong",[v._v("redux-saga")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中")])]),v._v(" "),e("li",[e("p",[v._v("action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function")])]),v._v(" "),e("li",[e("p",[v._v("异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理")])]),v._v(" "),e("li",[e("p",[v._v("功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤")])]),v._v(" "),e("li",[e("p",[v._v("灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程")])]),v._v(" "),e("li",[e("p",[v._v("易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等")])])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）")])]),v._v(" "),e("li",[e("p",[v._v("体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB）")])]),v._v(" "),e("li",[e("p",[v._v("功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码")])]),v._v(" "),e("li",[e("p",[v._v("对 TS ⽀持不友好：yield ⽆法返回 TS 类型")])])]),v._v(" "),e("p",[e("strong",[v._v("redux-observable")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理")])]),v._v(" "),e("li",[e("p",[v._v("知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤")])])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库")])]),v._v(" "),e("li",[e("p",[v._v("社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);